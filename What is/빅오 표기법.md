# 빅오(Big O) 표기법
```
최근 알고리즘 공부를 하면서 TimeOut을 경험했다. 왜 그런지 이유를 찾아보면 빅오 O(n^2) 이런 글자가 보였다.
정처기 공부할때 간혹 보던 내용이지만 다른 내용이 더 급해서 자세히 보지 못했던 내용을 이제야 정리해본다.
정리를 하고나서 내 코드가 왜 오류가 났는지 알 수 있었다. 이중포문 사용을 줄이는 방법에 대해 고민해볼 필요가 있을것 같다.
```

### 개념
* 알고리즘의 효율성을 표현하는 방법
* 컴퓨터가 연산하는 횟수

### 특징
* 상수항 무시 : 빅오 표기법은 데이터 입력값(n)이 충분히 크다고 가정하고 있고, 알고리즘의 효율성 또한 데이터 입력값(n)의 크기에 따라 영향 받기 때문에 상수항 같은 사소한 부분은 무시한다.
* 영향력 없는 항 무시 : 빅오 표기법은 데이터 입력값(n)의 크기에 따라 영향을 받기 때문에 가장 영향력이 큰 항에 이외에 영향력이 없는 항들은 무시한다.

### 시간복잡도 순서
![image](https://user-images.githubusercontent.com/97998574/185743226-de663f55-9e9f-4ed0-92a6-2fb93b8f11aa.png)
* 시간복잡도는 다음과 같은 순서로 빠르다.   
* **O(1) > O(logn) > O(n) > O(nlogn) > O(n^c) > O(c^n) > O(n!)**
* O(1) : 입력값에 상관없이 일정한 실행시간을 최고!의 알고리즘이라 할 수 있다.   
  하지만 상수 시간에 실행된다 해도 상수값이 상상 이상으로 클 경우 사실상 일정한 시간의 의미가 없다.    
  최고의 알고리즘이 될 수 있지만 그만큼 신중해야 한다.
* O(log n) : 로그는 매우 큰 입력값에서도 크게 영향을 받지 않는 편이다. 매우 견고한 알고리즘으로 **이진 탐색**의 경우가 이에 해당한다.
* O(n) : 알고리즘을 수행하는데 걸리는 시간은 입력값에 비례한다. 이러한 알고리즘을 **선형 시간 알고리즘**이라 부른다.    
정렬되지 않은리스트에서 최대 또는 최솟값을 찾는 경우가 해당되며 모든 입렵값을 적어도 한 번 이상은 살펴봐야 한다.
* O (n log n) : 병합 정렬등의 대부분 효율이 좋은 알고리즘이 이에 해당 한다. 아무리 좋은 알고리즘이라 할지라도 n log n 보다 빠를 수 없다.   
  입력값이 최선일 경우, 비교를 건너 뛰어 O(n)이 될 수 있다.
* O(n^2)  : **버블 정렬** 같은 비효율적인 정렬 알고리즘이 이에 해당 한다.
* O(2^n) : **피보나치의 수를 재귀로 계산하는 알고리즘**이 이에 해당 한다.   
  n^2와 혼동되는 경우가 있는데 2^n이 훨씬 더 크다.
* O(n!) : 가장 느린 알고리즘으로 입력값이 조금만 커져도 계산이 어렵다.
